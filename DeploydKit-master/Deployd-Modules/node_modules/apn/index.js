var apns = require('apn')
  , Resource = require('deployd/lib/resource')
  , util = require('util');

function Apn(name, options) {
  Resource.apply(this, arguments);
  if (!this.apnsConnection && this.config.cert && this.config.gateway && this.config.port) {
      var options = {
        cert: this.config.cert,                   // Certificate file path
        certData: this.config.certData,           // String or Buffer containing certificate data, if supplied uses this instead of cert file path
        key:  this.config.key,                    // Key file path
        keyData: this.config.keyData,             // String or Buffer containing key data, as certData
        passphrase: this.config.passphrase,       // A passphrase for the Key file
        ca: this.config.ca,                       // String or Buffer of CA data to use for the TLS connection
        gateway: this.config.gateway,             // gateway address
        port: this.config.port,                   // gateway port
        enhanced: this.config.enhanced,           // enable enhanced format
        errorCallback: this.config.errorCallback, // Callback when error occurs function(err,notification)
        cacheLength: this.config.cacheLength      // Number of notifications to cache for error purposes
      };
      this.apnsConnection = new apns.Connection(options);
  }
}

util.inherits(Apn, Resource);
module.exports = Apn;
Apn.label = "Apn";
Apn.prototype.clientGeneration = true;
Apn.events = ["post"];
Apn.basicDashboard = {
  settings: [{
      name: 'cert'
    , type: 'string'
  }, {
      name: 'certData'
    , type: 'string'
  }, {
      name: 'key'
    , type: 'string'
  }, {
      name: 'keyData'
    , type: 'string'
  }, {
      name: 'passphrase'
    , type: 'string'
  }, {
      name: 'ca'
    , type: 'string'
  }, {
      name: 'gateway'
    , type: 'string'
  }, {
      name: 'port'
    , type: 'number'
  }, {
      name: 'enhanced'
    , type: 'boolean'
  }, {
     name: 'errorCallback'
   , type: 'string'
  }, {
     name: 'cacheLength'
   , type: 'number'
}]
};

Apn.prototype.handle = function (ctx, next) {
  var req = ctx.req
    , apn = this;

  if (!this.apnsConnection) return ctx.done("Missing apn configuration!");
    
  if (req.method === "POST") {      
      ctx.dpd.channel.get({channels: {$in: ctx.body.channels}},
                          function(results, error) {
                            if (error) return ctx.done(error);
                            results.forEach(function(channel) {
                                              apn.sendNotification(channel, ctx.body.data, ctx, next);
                                            });
                         });
      
  } else {
    next();
  }
};


Apn.prototype.sendNotification = function(channel, payload, ctx, next) {
    var req = ctx.req;
    
    var channelBadge = channel.badge;
    var channelToken = channel.deviceToken;
    if(!channelToken){
        req.resume();
        return;
    }
    
    /*
     The special "Increment" badge value will tell that the badge
     field for each matching Channel should be incremented and the
     new value used in the push payload
     */
    if(payload.badge == 'Increment'){
        channelBadge++;
        ctx.dpd.channel.put(channel.id,{badge: {$inc: 1}},
                                        function(result, error) {
                                            if (error) return ctx.done(error);
                                        });
    }
    delete payload['badge'];                          
    var payloadAlert = payload.alert;
    delete payload['alert'];
    var payloadSound = payload.sound;
    delete payload['sound'];                                                    
                          
    var note = new apns.Notification();
    note.expiry = Math.floor(Date.now() / 1000) + 3600; // Expires 1 hour from now.
    note.badge = channelBadge;
    if(payloadSound)
        note.sound = payloadSound;
    if(payloadAlert)
        note.alert = payloadAlert;
    note.payload = payload; 
    note.device = new apns.Device(channelToken);
    this.apnsConnection.sendNotification(note);
    
    req.resume();
};
